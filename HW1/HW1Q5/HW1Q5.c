#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <time.h>
#include <string.h>

//Compiled and run using CodeBlocks
/*Initial vector is generated by using local time as seed then calling rand()*/
//ASCII is converted to uppercase then to format to match A to Z [0...25]
const int plaintextLength = 64; //defines plaintext length n. It is also the maximum default key length

const int frontStringLength = 17; //defines length of string that will be appended at the beginning of plaintext
void frontStringGen(char*);
void convertToNum(char*, int);//convert A to Z into numbers between 0 to 25
void convertToASCII(char*, int);

int getMyKey(char*);
void keyArrayGen(char*, char*, int, int);

void vigenereEncrypt(char*, char*, char*, int);
void vigenereDecrypt(char*, char*, char*, int);

void frontStringGen(char* inputArray){//Upper portion not yet generated randomly.
    srand(time(0));
    for(int i = 0; i < frontStringLength; i++){
        inputArray[i] = (rand() % 26) + 65; //Ensure the result is between ASCII values of capital A to Z.
    }
    inputArray[frontStringLength] = '\0';
}

void convertToNum(char* string, int stringLength){
    for(int i = 0; i < stringLength; i++){
        string[i] = string[i] - 65; //Convert to numbers between 0 to 25
    }

}
void convertToASCII(char* string, int stringLength){
    for(int i = 0; i < stringLength; i++){
        string[i] = string[i] + 65; //Convert to ASCII numbers
    }

}

int getMyKey(char* myKey){
    //Getting the specified key, counting actual key length
    int counter;
    do{
        printf("Enter your key which has a length of non-17 multiple with no space: \n");
        scanf("%s", myKey);
        printf("\n");
        printf( "You entered: %s \n", myKey);
        counter = 0;
        while(counter < plaintextLength && myKey[counter] != '\0'){
            myKey[counter] = toupper(myKey[counter]);
            counter++;
        }
        if(counter % 17 == 0){//Reject keys that does not satisfy the requirement.
            printf("Your key has a length of %d . It is a multiple of 17 and does not fit the length requirement. \n", counter);
        }
    }while(counter % 17 == 0);

    return counter;

}

void keyArrayGen(char* keyPadded, char* myKey, int keySize, int expectedLength){
    for(int i = 0; i < expectedLength; i++){
        keyPadded[i] = myKey[i % keySize];//pad the input key to 32 byte, same as size IV.
    }
    keyPadded[expectedLength] = '\0';
}

void vigenereEncrypt(char* plaintext, char* ciphertext, char* key, int inputLength){
    for(int i = 0; i < inputLength; i++){
        ciphertext[i] = (plaintext[i] + key[i]) % 26;
    }
    ciphertext[inputLength] = '\0';

}
void vigenereDecrypt(char* plaintext, char* ciphertext, char* key, int inputLength){
    for(int i = 0; i < inputLength; i++){
        plaintext[i] = ((ciphertext[i] - key[i]) % 26 + 26) % 26; //Formal modulo operation implemented in case of a negative value modding a positive value
    }
    plaintext[inputLength] = '\0';

}


int main()
{
    char plaintext[plaintextLength];
    printf("Enter your plaintext at most %d character with no space or symbol: \n", plaintextLength);
    scanf("%s", plaintext);
    printf("\n");
    printf( "You entered: %s \n", plaintext);


    /*Process input plaintext*/
    int actualLength = 0;
    for(int i = 0; (i < plaintextLength && plaintext[i] != '\0'); i++){
        actualLength++;//Calculate actual length of plaintext
    }
    printf("Actual length of this input is: %d \n", actualLength);

    for(int i = 0; i < actualLength ; i++){ //Convert to uppercase and check whether symbols are in
        if( (plaintext[i] >= 65 && plaintext[i] <= 90) || (plaintext[i] >= 97 && plaintext[i] <= 122) ){//Check whether the input is in the Range of alphabets
            plaintext[i] = toupper(plaintext[i]); //Convert to uppercase if in ranges of alphabet
        }
        else{//Symbols found, prompt to re-enter a new string.
            printf("There are symbols or spaces in the input: %s \n", plaintext);
            printf("Enter your plaintext at most %d character with no space or symbol: \n", plaintextLength);
            scanf("%s", plaintext);
            printf("\n");
            printf( "You entered: %s \n", plaintext);

            /*Recalculate actual length*/
            actualLength = 0;
            for(int j = 0; (j < plaintextLength && plaintext[j] != '\0'); j++){
                actualLength++;
            }
            printf("Actual length for this new input is: %d \n", actualLength);
            i = -1;//restart to uppercase conversion. set to -1 due to i++ and the end of for loop.
        }
    }
    printf("After converting to uppercase: %s \n", plaintext);


    /*Generating front string */
    char frontString[frontStringLength];//Front portion of stringX
    frontStringGen(frontString);
    printf("The front portion of stringX generated is: %s \n", frontString);

    /*Generating stringX. Here, stringX[0] is X_1, stringX[16] is X_17, stringX[17] till the end is X_18 to X_n+17*/
    char stringX[frontStringLength + actualLength];
    strcpy(stringX, frontString);
    strcat(stringX, plaintext);
    printf("stringX after concatenation of front portion and plaintext is: %s \n", stringX);

    /*Convert ASCII to numbers, so [A...Z] is [0...25] for stringX, front portion of stringX and plaintext portion of stringX*/
    convertToNum(stringX, frontStringLength + actualLength);//Converting stringX to number format
    printf("stringX in number format is: ");
    for(int i = 0; i < frontStringLength + actualLength; i++){
        printf("%d ", stringX[i]);
    }
    printf("\n");

    //Converting front portion of stringX to number format
    printf("front portion of stringX in number format is: ");
    for(int i = 0; i < frontStringLength; i++){
        frontString[i] = stringX[i]; //Retrieve the converted result from stringX
        printf("%d ", frontString[i]);
    }
    printf("\n");

    //Converting plaintext portion of stringX to number format
    printf("Plaintext portion of stringX in number format is: ");
    for(int i = 0; i < actualLength; i++){
        plaintext[i] = stringX[i + frontStringLength];//Retrieve the converted result from stringX
        printf("%d ", plaintext[i]);
    }
    printf("\n");

    /*Encrypt plaintext portion of stringX for stringY generation*/
    char encryptedRemainderOfStringX[actualLength];
    char paddedFrontStringX[actualLength];
    keyArrayGen(paddedFrontStringX, frontString, frontStringLength, actualLength); //Pad front portion of string the same length as the plaintext portion.
    printf("padded front portion of stringX in number format is: ");
    for(int i = 0; i < actualLength; i++){
        printf("%d ", paddedFrontStringX[i]);
    }
    printf("\n");

    vigenereEncrypt(plaintext, encryptedRemainderOfStringX, paddedFrontStringX, actualLength); //Encrypting the stringX[17] till the end of string

    printf("Encrypted portion of stringX in number format is: ");
    for(int i = 0; i < actualLength; i++){
        printf("%d ", encryptedRemainderOfStringX[i]);
    }
    printf("\n");
    /*combine front string and encrypted plaintext to get stringY*/
    char stringY[frontStringLength + actualLength];

    for(int i = 0, j = 0; i < frontStringLength + actualLength; i++){//i: index in stringY, j: index in excryptedRemainderOfStringX
        if(i < frontStringLength){
            stringY[i] = frontString[i];
        }
        else{
            stringY[i] = encryptedRemainderOfStringX[j];
            j++;
        }
    }

    printf("stringY in number format is: ");
    for(int i = 0; i < frontStringLength + actualLength; i++){
        printf("%d ", stringY[i]);
    }
    printf("\n");

    /*Input key*/
    char inputKey[plaintextLength];
    int actualKeyLength = getMyKey(inputKey);//get the generated key and the length entered
    printf("The key has a length of %d \n", actualKeyLength);

    /*Pad the key as long as the length of stringY*/
    char keyPadded[frontStringLength + actualLength];
    keyArrayGen(keyPadded, inputKey, actualKeyLength, frontStringLength + actualLength);

    printf("keyPadded in string is: %s \n", keyPadded);

    /*Convert the key entered into number format, so [A...Z] is [0...25]*/
    convertToNum(keyPadded,frontStringLength + actualLength);
    printf("keyPadded in number format is: ");
    for(int i = 0; i < frontStringLength + actualLength; i++){
        printf("%d ", keyPadded[i]);
    }
    printf("\n");

    /*Encrypt stringY*/
    char encryptedStringY[frontStringLength + actualLength];
    vigenereEncrypt(stringY, encryptedStringY, keyPadded, frontStringLength + actualLength);
    printf("encryptedStringY in number format is: ");
    for(int i = 0; i < frontStringLength + actualLength; i++){
        printf("%d ", encryptedStringY[i]);
    }
    printf("\n");

    /*Convert stringY back to ASCII for output*/
    convertToASCII(encryptedStringY, frontStringLength + actualLength);
    printf("encryptedStringY is: %s \n", encryptedStringY);

    /*Decryption procedure*/
    printf("\nNow starting decryption... \n");

    convertToNum(encryptedStringY, frontStringLength + actualLength);//Convert stringY back to number format
    printf("encryptedStringY in number format is: ");
    for(int i = 0; i < frontStringLength + actualLength; i++){
        printf("%d ", encryptedStringY[i]);
    }
    printf("\n");

    printf("keyPadded in number format is: ");
    for(int i = 0; i < frontStringLength + actualLength; i++){
        printf("%d ", keyPadded[i]);
    }
    printf("\n");

    vigenereDecrypt(stringY, encryptedStringY, keyPadded, frontStringLength + actualLength);//Decrypt stringY
    printf("stringY after decryption in number format is: ");
    for(int i = 0; i < frontStringLength + actualLength; i++){
        printf("%d ", stringY[i]);
    }
    printf("\n");

    //Extract stringY back into 2 portions
    printf("frontString in number format is: ");
    for(int i = 0, j = 0; i < frontStringLength + actualLength; i++){//i: index in stringY, j: index in excryptedRemainderOfStringX
        if(i < frontStringLength){//first 17 elements of stringX
            frontString[i] = stringY[i];
            printf("%d ", frontString[i]);
            if(i == frontStringLength - 1){
                printf("\n");
                printf("encryptedRemainderOfStringX in number format is: ");
            }
        }else{//Retrieve encrypted stringX using first 17 elements.
            encryptedRemainderOfStringX[j] = stringY[i];
            printf("%d ", encryptedRemainderOfStringX[j]);
            j++;
        }

    }
    printf("\n");

    //Decrypt the encrypted stringX using padded first 17 elements as key
    char decryptedPlaintext[actualLength];

    keyArrayGen(paddedFrontStringX, frontString, frontStringLength, actualLength); //Pad the decrypted first 17 elements of stringX

    printf("padded and decrypted front portion of stringX in number format is: ");
    for(int i = 0; i < actualLength; i++){

        printf("%d ", paddedFrontStringX[i]);
    }
    printf("\n");

    vigenereDecrypt(decryptedPlaintext, encryptedRemainderOfStringX, paddedFrontStringX, actualLength);
    printf("decryptedPlaintext in number format is: ");
    for(int i = 0; i < actualLength; i++){
        printf("%d ", decryptedPlaintext[i]);
    }
    printf("\n");

    //Convert to ASCII values for output.
    convertToASCII(decryptedPlaintext, actualLength);
    printf("Decrypted plaintext in string format is: %s \n", decryptedPlaintext);

    printf("Execution finished. \n");
    system( "PAUSE" );
    return 0;
}
