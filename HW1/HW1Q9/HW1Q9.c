#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//In c, char is 1 byte long
//Compiled and run using CodeBlocks
/*Space is not allowed in keys or plaintexts.*/
/*Initial vector is generated by using local time as seed then calling rand()*/
/*Encryption and decryption is based on the ASCII values of each character*/
/*Encrypted data and initial vector may display in incompatible characters in the command console.*/
const int defaultLength = 32;   //default length for key and IV
const int defaultTextLength = 32;   //default maximum length for pt and ct
const int defaultKeyStreamBytesDropped = 3072;
void init(char* initVector);

int getMyKey(char*);
void keyArrayGen(char*, char*, int);

void KSA(char*,char*);
void PRGA(char*, char*);

void encrypt(char*,char* , char* );
void decrypt(char*,char* , char* );

void init(char* initVector){//initVector is S.

    srand(time(0)); //using local time as seed, generate random number for each element of initial vector
    for (int i = 0; i < defaultLength; i++){
        initVector[i] = rand() % 128; //Only ASCII values from 0 to 127 are considered
    }
    initVector[defaultLength] = '\0';

}

int getMyKey(char* myKey){
    //Getting the specified key, counting actual key length
    int counter;
    do{
        printf("Enter your 16 to 32 bytes key with no space: \n");
        scanf("%s", myKey);
        printf("\n");
        printf( "You entered: %s \n", myKey);
        counter = 0;
        while(counter < defaultLength && myKey[counter] != '\0'){
            counter++;
        }
        if(counter < 16 || counter > 32){//Reject keys that does not satisfy the requirement.
            printf("Your key is %d byte(s). It does not meet the length requirement. \n", counter);
        }
    }while(counter < 16 || counter > 32);

    return counter;

}

void keyArrayGen(char* keyPadded, char* myKey, int keySize){
    for(int i = 0; i < defaultLength; i++){
        keyPadded[i] = myKey[i % keySize];//pad the input key to 32 byte, same as size IV.
    }
    keyPadded[defaultLength] = '\0';
}

void KSA(char* initVector, char* keyPadded){ //Key Scheduling Algorithm
    int j = 0; //Swap index
    for (int i = 0; i < defaultLength; i++){
        j = (j + initVector[i] + keyPadded[i]) % defaultLength;
        /*Swap S[i] and S[j]*/
        char temp;
        temp = initVector[i];
        initVector[i] = initVector[j];
        initVector[j] = temp;
    }
}
void PRGA(char* initVector, char* keyStream){ //Pseudo-random generation algorithm
    int i = 0, j = 0;//Swap index
    int t; //index which the key stream will use
    unsigned int counter = 0; //counter of the keyStream
    for(i = i + 1; counter < defaultTextLength + defaultKeyStreamBytesDropped; counter++){//generate keyStream long enough to drop the first 3072 bytes then XOR with plaintext
        j = (j + initVector[i]) % defaultLength;
        char temp;
        temp = initVector[i];
        initVector[i] = initVector[j];
        initVector[j] = temp;

        t = (initVector[i] + initVector[j]) % defaultLength;
        keyStream[counter] = initVector[t];
        i = (i + 1) % defaultLength;
    }
    keyStream[defaultTextLength + defaultKeyStreamBytesDropped] = '\0';

}
void encrypt(char* encryptResult,char* pt, char* keyStream){
    for(int i = 0; i < defaultTextLength; i++){
        encryptResult[i] = pt[i] ^ keyStream[defaultKeyStreamBytesDropped + 1 + i];//Encrypt plaintext by XOR with key stream that has its first 3072 bytes dropped.
    }
    encryptResult[defaultTextLength] = '\0';
    return;
}
void decrypt(char* decryptResult, char* ct, char* keyStream){
    for(int i = 0; i < defaultTextLength; i++){
        decryptResult[i] = ct[i] ^ keyStream[defaultKeyStreamBytesDropped + 1 + i];//Decrypt ciphertext by XOR with key stream
    }
    decryptResult[defaultTextLength] = '\0';
    return;
}

int main()
{
    /*Driver for all the functions above*/
    char initVector[defaultLength];
    init(initVector);
    printf("Initial Vector in string is: %s \n", initVector);
    printf("Initial Vector in ASCII number is: ");
    for(int i = 0; i < defaultLength; i++){
        printf("%d ", initVector[i]);
    }
    printf("\n");

    char myKey[defaultLength];
    int keySize = getMyKey(myKey);
    printf("Size of key is %d bytes. \n", keySize);

    char keyPadded[defaultLength];
    keyArrayGen(keyPadded, myKey, keySize);
    printf("keyPadded in string is: %s \n", keyPadded);
    printf("keyPadded in ASCII number is: ");
    for(int i = 0; i < defaultLength; i++){
        printf("%d ", keyPadded[i]);
    }
    printf("\n");

    KSA(initVector, keyPadded);
    printf("Initial Vector (S) in string after KSA is %s \n", initVector);
    printf("Initial Vector (S) in ASCII after KSA is: ");
    for(int i = 0; i < defaultLength; i++){
        printf("%d ", initVector[i]);
    }
    printf("\n");

    char keyStream[defaultTextLength + defaultKeyStreamBytesDropped];
    PRGA(initVector, keyStream);
    printf("Initial Vector (S) in string after PRGA is %s \n", initVector);
    printf("Initial Vector (S) in ASCII after PRGA is: ");
    for(int i = 0; i < defaultLength; i++){
        printf("%d ", initVector[i]);
    }
    printf("\n");

    /*
    printf("keyStream in ASCII is: ");
    for(int i = 0; i < defaultLength; i++){
        printf("%d ", keyStream[i]);
    }
    printf("\n");
    */


    char plaintext[defaultTextLength];
    printf("Enter your plaintext, at most %d bytes long: \n", defaultTextLength);
    scanf("%s", plaintext);
    printf("The entered plaintext in ASCII format is: ");
    for(int i = 0; i < defaultTextLength; i++){
        printf("%d ", plaintext[i]);
    }
    printf("\n");

    /*Encryption*/
    char encryptResult[defaultTextLength];
    encrypt(encryptResult, plaintext, keyStream);
    printf("\n");
    printf("Encryption result in string is: %s \n", encryptResult);
    printf("Encryption result in ASCII is: ");
    for(int i = 0; i < defaultTextLength; i++){
        printf("%d ", encryptResult[i]);
    }
    printf("\n");
    /*Decrypt the result of encryption to check whether the original plaintext can be recovered*/
    char decryptResult[defaultTextLength];
    decrypt(decryptResult, encryptResult, keyStream);
    printf("Decryption result is: %s \n", decryptResult);

    printf("Execution finished. \n");
    system( "PAUSE" );
    return 0;
}
